[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The QPL Book",
    "section": "",
    "text": "Welcome to The QPL Book\nLearn quantum computing and Measurement-Based Quantum Computing (MBQC) using the Quantum Process Language (QPL) - a relations-first approach to quantum programming.",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#what-youll-learn",
    "href": "index.html#what-youll-learn",
    "title": "The QPL Book",
    "section": "What You’ll Learn",
    "text": "What You’ll Learn\nThis book teaches quantum computing from first principles, building up to advanced topics in MBQC and photonic quantum computing:\n\nPart I: Quantum Foundations - Understand qubits, entanglement, and n-qubit systems\nPart II: MBQC Theory - Learn cluster states, graph states, and measurement patterns\nPart III: QPL Programming - Write quantum programs with hands-on tutorials\nPart IV: Advanced Topics - Explore tensor networks, categorical quantum mechanics, and fault-tolerant QC",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#why-qpl",
    "href": "index.html#why-qpl",
    "title": "The QPL Book",
    "section": "Why QPL?",
    "text": "Why QPL?\nUnlike gate-based quantum languages (Qiskit, Cirq, Q#), QPL treats quantum entanglement as a first-class primitive, making it natural to express:\n\nCluster states for MBQC\nMeasurement patterns for photonic quantum computers\nRelations-first quantum algorithms\nGraph state compilation",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "The QPL Book",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nMathematics: Linear algebra, complex numbers, basic probability\nProgramming: Python basics (QPL is implemented in Python)\nPhysics: Helpful but not required - we explain quantum mechanics from scratch",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "The QPL Book",
    "section": "How to Use This Book",
    "text": "How to Use This Book\n\nFor Learners\nStart with Part I to build quantum foundations, then move through hands-on tutorials in Part III.\n\n\nFor Researchers\nJump to Part II for MBQC theory or Part IV for advanced topics like tensor networks.\n\n\nFor Programmers\nInstall QPL and dive into Part III tutorials - learn by doing!",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "The QPL Book",
    "section": "Installation",
    "text": "Installation\npip install quantum-process-language\nSee Appendix: Installation for detailed setup instructions.",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#code-examples",
    "href": "index.html#code-examples",
    "title": "The QPL Book",
    "section": "Code Examples",
    "text": "Code Examples\nAll code in this book is: - Executable - Run examples directly in your Python environment - Open source - Available at github.com/dcoldeira/quantum-process-language - Tested - Every example is verified to work with the latest QPL release",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#about-the-author",
    "href": "index.html#about-the-author",
    "title": "The QPL Book",
    "section": "About the Author",
    "text": "About the Author\nDavid Coldeira is a scientific software engineer with a BSc in Physics, specializing in quantum programming languages and MBQC. He developed QPL to explore relations-first approaches to quantum computing.\n\nEmail: dcoldeira@gmail.com\nGitHub: (dcoldeira?)\nBlog: dcoldeira.github.io",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "The QPL Book",
    "section": "Contributing",
    "text": "Contributing\nFound a typo? Have a suggestion? Contributions are welcome!\n\nIssues: github.com/dcoldeira/qpl-book/issues\nPull requests: github.com/dcoldeira/qpl-book",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "The QPL Book",
    "section": "License",
    "text": "License\n\nText: Creative Commons BY-SA 4.0\nCode: MIT License (same as QPL)\n\n\nLet’s begin! Jump straight to hands-on tutorials: - Chapter 7: Your First Bell State - Chapter 8: Understanding GHZ States\n(Foundational chapters 1-6 coming soon!)",
    "crumbs": [
      "Welcome to The QPL Book"
    ]
  },
  {
    "objectID": "chapters/01-placeholder.html",
    "href": "chapters/01-placeholder.html",
    "title": "1  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part I: Quantum Foundations",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/02-placeholder.html",
    "href": "chapters/02-placeholder.html",
    "title": "2  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part I: Quantum Foundations",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/03-placeholder.html",
    "href": "chapters/03-placeholder.html",
    "title": "3  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part I: Quantum Foundations",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/04-placeholder.html",
    "href": "chapters/04-placeholder.html",
    "title": "4  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part II: Measurement-Based Quantum Computing",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/05-placeholder.html",
    "href": "chapters/05-placeholder.html",
    "title": "5  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part II: Measurement-Based Quantum Computing",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/06-placeholder.html",
    "href": "chapters/06-placeholder.html",
    "title": "6  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part II: Measurement-Based Quantum Computing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/07-first-bell-state.html",
    "href": "chapters/07-first-bell-state.html",
    "title": "7  Your First Bell State",
    "section": "",
    "text": "7.1 What is a Bell State?\nA Bell state is a maximally entangled 2-qubit quantum state. The most common Bell state is:\n\\[\n|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\n\\]\nThis state has fascinating properties: - Superposition: Equal probability of measuring \\(|00\\rangle\\) or \\(|11\\rangle\\) - Perfect correlation: If you measure qubit A as 0, qubit B will always be 0 - Maximal entanglement: Entropy \\(S = 1.0\\) (maximum for 2 qubits)",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Your First Bell State</span>"
    ]
  },
  {
    "objectID": "chapters/07-first-bell-state.html#setting-up",
    "href": "chapters/07-first-bell-state.html#setting-up",
    "title": "7  Your First Bell State",
    "section": "7.2 Setting Up",
    "text": "7.2 Setting Up\nFirst, make sure QPL is installed:\npip install quantum-process-language\nCreate a new Python file my_first_bell_state.py:\n\nfrom qpl import QPLProgram, create_question, QuestionType\n\n# Create a quantum program\nprogram = QPLProgram(\"My First Bell State\")",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Your First Bell State</span>"
    ]
  },
  {
    "objectID": "chapters/07-first-bell-state.html#creating-quantum-systems",
    "href": "chapters/07-first-bell-state.html#creating-quantum-systems",
    "title": "7  Your First Bell State",
    "section": "7.3 Creating Quantum Systems",
    "text": "7.3 Creating Quantum Systems\nIn QPL, you don’t create individual “qubits” - you create quantum systems that can then be entangled into relations:\n\n# Create two quantum systems\nqubit_a = program.create_system()\nqubit_b = program.create_system()\n\nprint(f\"Created systems: {qubit_a.system_id} and {qubit_b.system_id}\")\n\nEach system gets a unique ID. At this point, they’re independent - not yet entangled.",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Your First Bell State</span>"
    ]
  },
  {
    "objectID": "chapters/07-first-bell-state.html#entangling-systems",
    "href": "chapters/07-first-bell-state.html#entangling-systems",
    "title": "7  Your First Bell State",
    "section": "7.4 Entangling Systems",
    "text": "7.4 Entangling Systems\nHere’s where QPL’s philosophy shines. Instead of applying gates like CNOT, you directly express the relationship you want:\n\n# Create a Bell pair (maximally entangled state)\nbell_pair = program.entangle(qubit_a, qubit_b)\n\nprint(f\"Bell state created!\")\nprint(f\"State vector shape: {bell_pair.state.shape}\")\nprint(f\"Entanglement entropy: {bell_pair.entanglement_entropy:.3f}\")\n\nOutput:\nBell state created!\nState vector shape: (4,)\nEntanglement entropy: 1.000\nThe entropy of 1.0 confirms this is maximally entangled.",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Your First Bell State</span>"
    ]
  },
  {
    "objectID": "chapters/07-first-bell-state.html#understanding-the-state",
    "href": "chapters/07-first-bell-state.html#understanding-the-state",
    "title": "7  Your First Bell State",
    "section": "7.5 Understanding the State",
    "text": "7.5 Understanding the State\nLet’s look at the actual quantum state:\n\nimport numpy as np\n\nprint(\"Bell state vector:\")\nprint(bell_pair.state)\nprint()\nprint(\"In basis notation:\")\nprint(f\"|00⟩: {bell_pair.state[0]:.3f}\")\nprint(f\"|01⟩: {bell_pair.state[1]:.3f}\")\nprint(f\"|10⟩: {bell_pair.state[2]:.3f}\")\nprint(f\"|11⟩: {bell_pair.state[3]:.3f}\")\n\nOutput:\nBell state vector:\n[0.707+0j  0.+0j  0.+0j  0.707+0j]\n\nIn basis notation:\n|00⟩: 0.707\n|01⟩: 0.000\n|10⟩: 0.000\n|11⟩: 0.707\nThis is exactly \\(\\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\\)! (Note: \\(0.707 \\approx \\frac{1}{\\sqrt{2}}\\))",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Your First Bell State</span>"
    ]
  },
  {
    "objectID": "chapters/07-first-bell-state.html#complete-example",
    "href": "chapters/07-first-bell-state.html#complete-example",
    "title": "7  Your First Bell State",
    "section": "7.6 Complete Example",
    "text": "7.6 Complete Example\nHere’s the complete program you can run:\n\nfrom qpl import QPLProgram, create_question, QuestionType\n\ndef main():\n    # Create program\n    program = QPLProgram(\"Complete Bell State Example\")\n\n    # Create quantum systems\n    qubit_a = program.create_system()\n    qubit_b = program.create_system()\n\n    # Entangle into Bell state\n    bell_pair = program.entangle(qubit_a, qubit_b)\n\n    # Show state information\n    print(\"=\" * 50)\n    print(\"BELL STATE CREATED\")\n    print(\"=\" * 50)\n    print(f\"State vector: {bell_pair.state}\")\n    print(f\"Entanglement entropy: {bell_pair.entanglement_entropy:.3f}\")\n    print(f\"Systems: {list(bell_pair.systems)}\")\n\nif __name__ == \"__main__\":\n    main()",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Your First Bell State</span>"
    ]
  },
  {
    "objectID": "chapters/07-first-bell-state.html#what-you-learned",
    "href": "chapters/07-first-bell-state.html#what-you-learned",
    "title": "7  Your First Bell State",
    "section": "7.7 What You Learned",
    "text": "7.7 What You Learned\nCongratulations! You’ve just:\n✅ Created your first quantum program in QPL ✅ Generated a maximally entangled Bell state ✅ Understood entanglement entropy ✅ Explored the quantum state vector\n\nNext: Chapter 8: Understanding GHZ States - Scale to 3+ qubits",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Your First Bell State</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html",
    "href": "chapters/08-ghz-states.html",
    "title": "8  Understanding GHZ States",
    "section": "",
    "text": "8.1 What is a GHZ State?\nGHZ (Greenberger-Horne-Zeilinger) states are maximally entangled states of 3 or more qubits. The 3-qubit GHZ state is:\n\\[\n|GHZ_3\\rangle = \\frac{|000\\rangle + |111\\rangle}{\\sqrt{2}}\n\\]\nFor n qubits:\n\\[\n|GHZ_n\\rangle = \\frac{|0\\rangle^{\\otimes n} + |1\\rangle^{\\otimes n}}{\\sqrt{2}} = \\frac{|00...0\\rangle + |11...1\\rangle}{\\sqrt{2}}\n\\]",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#why-ghz-states-matter",
    "href": "chapters/08-ghz-states.html#why-ghz-states-matter",
    "title": "8  Understanding GHZ States",
    "section": "8.2 Why GHZ States Matter",
    "text": "8.2 Why GHZ States Matter\nGHZ states are fundamental to quantum computing and quantum information:\n\nQuantum sensing - Heisenberg-limited precision measurements\nQuantum communication - Secret sharing protocols\nBell’s theorem - Demonstrate quantum non-locality\nQuantum error correction - Building blocks for logical qubits\nMBQC - Resource states for measurement-based computation",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#ghz-vs-bell-states",
    "href": "chapters/08-ghz-states.html#ghz-vs-bell-states",
    "title": "8  Understanding GHZ States",
    "section": "8.3 GHZ vs Bell States",
    "text": "8.3 GHZ vs Bell States\n\n\n\n\n\n\n\n\nProperty\nBell (2 qubits)\nGHZ (3+ qubits)\n\n\n\n\nState\n\\(\\frac{\\|00\\rangle + \\|11\\rangle}{\\sqrt{2}}\\)\n\\(\\frac{\\|000\\rangle + \\|111\\rangle}{\\sqrt{2}}\\)\n\n\nEntanglement\nBipartite (2-way)\nMultipartite (n-way)\n\n\nCorrelation\nPerfect pairwise\nPerfect n-way\n\n\nEntropy\nS = 1.0 (max)\nS = 1.0 (max for 1 vs n-1 split)\n\n\nRobustness\nLoss of 1 qubit = no entanglement\nLoss of 1 qubit = no entanglement\n\n\n\nKey difference: GHZ states exhibit genuine multipartite entanglement - you can’t decompose them into Bell pairs!",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#creating-a-3-qubit-ghz-state-in-qpl",
    "href": "chapters/08-ghz-states.html#creating-a-3-qubit-ghz-state-in-qpl",
    "title": "8  Understanding GHZ States",
    "section": "8.4 Creating a 3-Qubit GHZ State in QPL",
    "text": "8.4 Creating a 3-Qubit GHZ State in QPL\nIn QPL, creating GHZ states is as simple as Bell states - just entangle more systems:\n\nfrom qpl import QPLProgram\n\n# Create program\nprogram = QPLProgram(\"GHZ State Tutorial\")\n\n# Create 3 quantum systems\nq0 = program.create_system()\nq1 = program.create_system()\nq2 = program.create_system()\n\n# Entangle them into GHZ state\nghz3 = program.entangle(q0, q1, q2)\n\nprint(f\"GHZ state created!\")\nprint(f\"State vector shape: {ghz3.state.shape}\")\nprint(f\"Number of qubits: {len(ghz3.systems)}\")\nprint(f\"Entanglement entropy: {ghz3.entanglement_entropy:.3f}\")\n\nOutput:\nGHZ state created!\nState vector shape: (8,)\nNumber of qubits: 3\nEntanglement entropy: 1.000\nNotice: - State vector has \\(2^3 = 8\\) components (8-dimensional Hilbert space) - Entropy is still 1.0 (maximal for 1-vs-2 split)",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#examining-the-quantum-state",
    "href": "chapters/08-ghz-states.html#examining-the-quantum-state",
    "title": "8  Understanding GHZ States",
    "section": "8.5 Examining the Quantum State",
    "text": "8.5 Examining the Quantum State\nLet’s look at the amplitudes:\n\nimport numpy as np\n\nprint(\"GHZ state amplitudes:\")\nprint(ghz3.state)\nprint()\n\n# Print in computational basis\nbasis_labels = ['|000⟩', '|001⟩', '|010⟩', '|011⟩',\n                '|100⟩', '|101⟩', '|110⟩', '|111⟩']\n\nfor i, label in enumerate(basis_labels):\n    amp = ghz3.state[i]\n    prob = abs(amp)**2\n    print(f\"{label}: amplitude = {amp:.3f}, probability = {prob:.3f}\")\n\nOutput:\nGHZ state amplitudes:\n[0.707+0j  0.+0j  0.+0j  0.+0j  0.+0j  0.+0j  0.+0j  0.707+0j]\n\n|000⟩: amplitude = 0.707, probability = 0.500\n|001⟩: amplitude = 0.000, probability = 0.000\n|010⟩: amplitude = 0.000, probability = 0.000\n|011⟩: amplitude = 0.000, probability = 0.000\n|100⟩: amplitude = 0.000, probability = 0.000\n|101⟩: amplitude = 0.000, probability = 0.000\n|110⟩: amplitude = 0.000, probability = 0.000\n|111⟩: amplitude = 0.707, probability = 0.500\nPerfect! Only \\(|000\\rangle\\) and \\(|111\\rangle\\) have non-zero amplitudes, each with 50% probability.",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#ghz-correlations-the-triple-coincidence",
    "href": "chapters/08-ghz-states.html#ghz-correlations-the-triple-coincidence",
    "title": "8  Understanding GHZ States",
    "section": "8.6 GHZ Correlations: The Triple Coincidence",
    "text": "8.6 GHZ Correlations: The Triple Coincidence\nThe magic of GHZ states is perfect 3-way correlation:\n\nIf you measure all 3 qubits, they always give the same result\nEither all measure 0, or all measure 1\nNever mixed like 001 or 110\n\nLet’s verify:\n\nfrom qpl import create_question, QuestionType\n\ndef test_ghz_correlations(num_trials=100):\n    \"\"\"Verify GHZ state 3-way correlations.\"\"\"\n\n    all_same = 0  # Count trials where all 3 qubits match\n\n    for trial in range(num_trials):\n        # Create fresh GHZ state\n        program = QPLProgram(f\"GHZ Trial {trial}\")\n        q0 = program.create_system()\n        q1 = program.create_system()\n        q2 = program.create_system()\n        ghz = program.entangle(q0, q1, q2)\n\n        # Measure all 3 qubits in Z basis\n        question = create_question(QuestionType.SPIN_Z)\n        alice = program.add_perspective(\"alice\")\n        result = program.ask(ghz, question, perspective=\"alice\")\n\n        # Check if all outcomes are the same\n        outcomes = list(result.values())\n        if outcomes[0] == outcomes[1] == outcomes[2]:\n            all_same += 1\n\n    correlation = all_same / num_trials\n    print(f\"Trials: {num_trials}\")\n    print(f\"All 3 qubits matched: {all_same}/{num_trials}\")\n    print(f\"Perfect correlation rate: {correlation:.1%}\")\n    print()\n    print(\"Expected: 100% for GHZ state\")\n\n# Run the test\ntest_ghz_correlations(100)\n\nOutput:\nTrials: 100\nAll 3 qubits matched: 100/100\nPerfect correlation rate: 100.0%\n\nExpected: 100% for GHZ state\nPerfect 3-way correlation! This is genuine multipartite entanglement.",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#scaling-to-4-qubits",
    "href": "chapters/08-ghz-states.html#scaling-to-4-qubits",
    "title": "8  Understanding GHZ States",
    "section": "8.7 Scaling to 4+ Qubits",
    "text": "8.7 Scaling to 4+ Qubits\nQPL supports arbitrary n-qubit GHZ states. Let’s create a 5-qubit GHZ:\n\n# Create 5-qubit GHZ state\nprogram = QPLProgram(\"5-Qubit GHZ\")\n\n# Create 5 systems\nqubits = [program.create_system() for _ in range(5)]\n\n# Entangle all 5 into GHZ state\nghz5 = program.entangle(*qubits)\n\nprint(f\"5-qubit GHZ created!\")\nprint(f\"State vector size: {ghz5.state.shape} (2^5 = 32 dimensions)\")\nprint(f\"Systems: {len(ghz5.systems)}\")\nprint(f\"Entanglement entropy: {ghz5.entanglement_entropy:.3f}\")\n\n# Check the state\nprint(f\"\\n|00000⟩ amplitude: {ghz5.state[0]:.3f}\")\nprint(f\"|11111⟩ amplitude: {ghz5.state[-1]:.3f}\")\nprint(f\"All others: ~0.000\")\n\nOutput:\n5-qubit GHZ created!\nState vector size: (32,) (2^5 = 32 dimensions)\nSystems: 5\nEntanglement entropy: 1.000\n\n|00000⟩ amplitude: 0.707\n|11111⟩ amplitude: 0.707\nAll others: ~0.000\nThe pattern holds: \\(|GHZ_5\\rangle = \\frac{|00000\\rangle + |11111\\rangle}{\\sqrt{2}}\\)",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#partial-measurements-on-ghz-states",
    "href": "chapters/08-ghz-states.html#partial-measurements-on-ghz-states",
    "title": "8  Understanding GHZ States",
    "section": "8.8 Partial Measurements on GHZ States",
    "text": "8.8 Partial Measurements on GHZ States\nWhat happens if you measure just one qubit from a GHZ state?\n\n# Create GHZ state\nprogram = QPLProgram(\"Partial GHZ Measurement\")\nq0 = program.create_system()\nq1 = program.create_system()\nq2 = program.create_system()\nghz = program.entangle(q0, q1, q2)\n\nprint(\"Before measurement:\")\nprint(f\"State: {ghz.state}\")\nprint(f\"Entropy: {ghz.entanglement_entropy:.3f}\")\n\n# Measure only the first qubit\nquestion_z = create_question(QuestionType.SPIN_Z, subsystem=0)\nalice = program.add_perspective(\"alice\")\nresult = program.ask(ghz, question_z, perspective=\"alice\")\n\nprint(f\"\\nMeasured qubit 0: {result[q0.system_id]}\")\nprint(f\"\\nAfter measurement:\")\nprint(f\"State: {ghz.state}\")\nprint(f\"Entropy: {ghz.entanglement_entropy:.3f}\")\n\nPossible output (if measured 0):\nBefore measurement:\nState: [0.707 0. 0. 0. 0. 0. 0. 0.707]\nEntropy: 1.000\n\nMeasured qubit 0: 0\n\nAfter measurement:\nState: [1. 0. 0. 0. 0. 0. 0. 0.]\nEntropy: 0.000\nKey insight: Measuring one qubit collapses the entire GHZ state to a product state (\\(|000\\rangle\\) or \\(|111\\rangle\\)). The remaining qubits are no longer entangled!\nThis is different from some other entangled states (like W states, which we’ll see in Chapter 11).",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#ghz-states-and-quantum-non-locality",
    "href": "chapters/08-ghz-states.html#ghz-states-and-quantum-non-locality",
    "title": "8  Understanding GHZ States",
    "section": "8.9 GHZ States and Quantum Non-Locality",
    "text": "8.9 GHZ States and Quantum Non-Locality\nGHZ states provide the strongest violation of local realism (even stronger than Bell states).\nConsider this scenario: 1. Create a 3-qubit GHZ state 2. Send each qubit to Alice, Bob, and Charlie (far apart) 3. Each measures in X or Y basis 4. Compare results\nClassical prediction (local realism): Certain combinations should occur\nQuantum prediction (GHZ state): Some combinations never occur, violating local realism\nThis is the GHZ paradox - a starker demonstration of quantum non-locality than Bell’s theorem.",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#complete-working-example",
    "href": "chapters/08-ghz-states.html#complete-working-example",
    "title": "8  Understanding GHZ States",
    "section": "8.10 Complete Working Example",
    "text": "8.10 Complete Working Example\nHere’s a complete program to explore GHZ states:\n\nfrom qpl import QPLProgram, create_question, QuestionType\nimport numpy as np\n\ndef main():\n    print(\"=\" * 60)\n    print(\"GHZ STATE DEMONSTRATION\")\n    print(\"=\" * 60)\n\n    # Create 3-qubit GHZ state\n    program = QPLProgram(\"GHZ Demo\")\n    q0 = program.create_system()\n    q1 = program.create_system()\n    q2 = program.create_system()\n    ghz = program.entangle(q0, q1, q2)\n\n    # Display state information\n    print(f\"\\nState vector: {ghz.state}\")\n    print(f\"Entanglement entropy: {ghz.entanglement_entropy:.3f}\")\n    print(f\"Number of systems: {len(ghz.systems)}\")\n\n    # Test correlations\n    print(\"\\n\" + \"=\" * 60)\n    print(\"TESTING 3-WAY CORRELATIONS (10 trials)\")\n    print(\"=\" * 60)\n\n    for trial in range(10):\n        # Create fresh GHZ state for each trial\n        p = QPLProgram(f\"Trial {trial}\")\n        q0 = p.create_system()\n        q1 = p.create_system()\n        q2 = p.create_system()\n        ghz_trial = p.entangle(q0, q1, q2)\n\n        # Measure\n        question = create_question(QuestionType.SPIN_Z)\n        observer = p.add_perspective(\"observer\")\n        result = p.ask(ghz_trial, question, perspective=\"observer\")\n\n        outcomes = list(result.values())\n        outcome_str = ''.join(map(str, outcomes))\n\n        # Check if all match\n        all_match = \"✓\" if outcomes[0] == outcomes[1] == outcomes[2] else \"✗\"\n\n        print(f\"Trial {trial+1:2d}: {outcome_str} {all_match}\")\n\n    print(\"\\n✓ = All qubits match (expected behavior)\")\n    print(\"✗ = Mixed outcomes (should never happen for GHZ)\")\n\nif __name__ == \"__main__\":\n    main()\n\nSave as ghz_demo.py and run:\npython ghz_demo.py",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#performance-note-state-vector-size",
    "href": "chapters/08-ghz-states.html#performance-note-state-vector-size",
    "title": "8  Understanding GHZ States",
    "section": "8.11 Performance Note: State Vector Size",
    "text": "8.11 Performance Note: State Vector Size\nAs you add more qubits, the state vector grows exponentially:\n\n2 qubits: 4 complex numbers (32 bytes)\n3 qubits: 8 complex numbers (64 bytes)\n5 qubits: 32 complex numbers (256 bytes)\n10 qubits: 1,024 complex numbers (8 KB)\n20 qubits: 1,048,576 complex numbers (8 MB)\n30 qubits: 1,073,741,824 complex numbers (8 GB!)\n\nFor large systems, you’ll need: - Tensor networks (MPS/PEPS) - efficient approximations - Stabilizer formalism - exact for certain states (including GHZ!) - MBQC compilation - Convert to measurement patterns\nWe’ll explore these in Part IV: Advanced Topics.",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#what-you-learned",
    "href": "chapters/08-ghz-states.html#what-you-learned",
    "title": "8  Understanding GHZ States",
    "section": "8.12 What You Learned",
    "text": "8.12 What You Learned\nCongratulations! You now understand:\n✅ GHZ states - Maximally entangled n-qubit states ✅ Multipartite entanglement - Genuine n-way correlations ✅ Creating GHZ states in QPL with entangle(*qubits) ✅ Perfect correlations - All qubits measure the same ✅ Partial measurements - Measuring one collapses all ✅ Quantum non-locality - Stronger than Bell states",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#key-concepts",
    "href": "chapters/08-ghz-states.html#key-concepts",
    "title": "8  Understanding GHZ States",
    "section": "8.13 Key Concepts",
    "text": "8.13 Key Concepts\n\nGHZ state formula: \\(|GHZ_n\\rangle = \\frac{|0^n\\rangle + |1^n\\rangle}{\\sqrt{2}}\\)\nPerfect n-way correlation: All qubits always measure the same\nFragile to loss: Losing one qubit destroys all entanglement\nMultipartite: Can’t be decomposed into Bell pairs\nExponential scaling: State vector size = \\(2^n\\) complex numbers",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#exercises",
    "href": "chapters/08-ghz-states.html#exercises",
    "title": "8  Understanding GHZ States",
    "section": "8.14 Exercises",
    "text": "8.14 Exercises\n\n8.14.1 Exercise 1: Verify 4-Qubit GHZ\nCreate a 4-qubit GHZ state and verify: - State vector has correct form - All 4 qubits show perfect correlation (100 trials) - Entropy is 1.0\n\n\n8.14.2 Exercise 2: Cross-Basis GHZ Measurements\nMeasure a 3-qubit GHZ state in X-basis instead of Z-basis. Do correlations still hold? Why or why not?\nHint: Use QuestionType.SPIN_X\n\n\n8.14.3 Exercise 3: GHZ State Distribution\nRun 1000 trials of GHZ measurement. Count how many times you get: - All 0s: 000 - All 1s: 111 - Mixed: anything else\nPlot a histogram. What distribution do you expect?\n\n\n8.14.4 Exercise 4: Sequential Partial Measurements\nStart with 4-qubit GHZ. Measure qubits one by one: 1. Measure qubit 0 → observe state collapse 2. Measure qubit 1 → observe further collapse 3. Measure qubit 2 → what happens to entropy? 4. Measure qubit 3 → final state?\nTrack the entropy at each step.\n\n\n8.14.5 Exercise 5: Large GHZ State\nCreate the largest GHZ state your computer can handle: - Try 10, 15, 20 qubits - Measure memory usage - What’s your practical limit?\n\n\n\n\n\n\nMemory Warning\n\n\n\nA 25-qubit state vector requires ~256 MB of RAM. A 30-qubit state needs ~8 GB. Be careful when scaling up!",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#going-deeper",
    "href": "chapters/08-ghz-states.html#going-deeper",
    "title": "8  Understanding GHZ States",
    "section": "8.15 Going Deeper",
    "text": "8.15 Going Deeper\n\n8.15.1 Theory: Why GHZ ≠ Bell Pairs\nYou might wonder: “Can I build a 3-qubit GHZ from Bell pairs?”\nAnswer: No!\nGHZ states exhibit genuine multipartite entanglement that can’t be created from bipartite (2-qubit) entanglement alone. This is a deep result in quantum information theory.\nMathematically: GHZ states belong to a different entanglement class under LOCC (Local Operations and Classical Communication).\n\n\n8.15.2 Application: Quantum Secret Sharing\nGHZ states enable quantum secret sharing: - Alice has a secret bit - Encodes it in a GHZ state shared with Bob and Charlie - Any 2 of the 3 can reconstruct the secret - But no single person can learn it alone\nThis is impossible classically without trusted parties!\n\n\n8.15.3 Connection to MBQC\nGHZ states are resource states for measurement-based quantum computing: - Create large GHZ state - Measure qubits in chosen bases - Measurement pattern implements quantum algorithm - Output is measurement outcomes\nWe’ll explore this in Part II: MBQC Theory.\n\n\n\n\n\n\nNext Steps\n\n\n\nWant to compare GHZ with other entangled states?\n\nChapter 11: W States - Different kind of multipartite entanglement (robust to qubit loss!)\nChapter 5: Cluster States - Even more qubits, different structure (MBQC resource states)\nChapter 13: Categorical QM - String diagram representation of GHZ states",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/08-ghz-states.html#summary",
    "href": "chapters/08-ghz-states.html#summary",
    "title": "8  Understanding GHZ States",
    "section": "8.16 Summary",
    "text": "8.16 Summary\nGHZ states are the gateway to multipartite quantum systems. You’ve learned:\n\nHow to create them in QPL (just entangle(*qubits))\nTheir perfect n-way correlations\nHow they differ from Bell states\nTheir role in quantum non-locality\nHow they scale (and when to worry about memory)\n\nGHZ states are fundamental to quantum computing, quantum communication, and quantum sensing. Mastering them is essential for understanding advanced quantum protocols.\n\nNext: Chapter 9: Measurement in QPL - Explore different measurement bases and contexts",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Understanding GHZ States</span>"
    ]
  },
  {
    "objectID": "chapters/09-placeholder.html",
    "href": "chapters/09-placeholder.html",
    "title": "9  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/10-placeholder.html",
    "href": "chapters/10-placeholder.html",
    "title": "10  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/11-placeholder.html",
    "href": "chapters/11-placeholder.html",
    "title": "11  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part III: QPL Programming",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/12-placeholder.html",
    "href": "chapters/12-placeholder.html",
    "title": "12  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part IV: Advanced Topics",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/13-placeholder.html",
    "href": "chapters/13-placeholder.html",
    "title": "13  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part IV: Advanced Topics",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/14-placeholder.html",
    "href": "chapters/14-placeholder.html",
    "title": "14  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part IV: Advanced Topics",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "chapters/15-placeholder.html",
    "href": "chapters/15-placeholder.html",
    "title": "15  Coming Soon",
    "section": "",
    "text": "This chapter is under development…",
    "crumbs": [
      "Part IV: Advanced Topics",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Coming Soon</span>"
    ]
  },
  {
    "objectID": "appendix/installation.html",
    "href": "appendix/installation.html",
    "title": "16  Installation",
    "section": "",
    "text": "Installation guide coming soon…",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "appendix/api-reference.html",
    "href": "appendix/api-reference.html",
    "title": "17  API Reference",
    "section": "",
    "text": "API documentation coming soon…",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>API Reference</span>"
    ]
  }
]